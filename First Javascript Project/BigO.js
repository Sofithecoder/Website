// ალგორითმის კომპლექსურობა იგივე წარმადობა

// როგორ გავიგოთ რამდენ წამში შესრულდა ჩვენს მიერ გადაცემული ოპერაცია?
// performance.now()
console.log(performance.now());
for(let i=0; i<888; i++) {}
console.log(performance.now())
// პროგრამის გაშვებიდან პირველ შედეგამდე მოსვლას დასჭირდა 46 მილიწამი და მეორე შედეგამდე მოსვლას დასჭირდა 52-46 მილიწამი. ანუ 6 მილიწამი

const n = 500;
let sum = n *(n+1)/2
//ამის კომპლექსუროა არის O(1), იმიტომ, რომ n როგორც არუნდა შევცვალოთ, ოპერაციების რაოდენობა არ გაიზრდება
// ალგორითმის კომპლექსურობის გამოსახატად ვიყენებთ ასეთ ჩანაწერს O(1) მაგალითად 4 ცალ იგივე ტიპის ოპერაციას თუ უშვებ O(4) არაა საჭირო, O(1)საკმარისია
// O(1) ნიშნავს, რომ დათვლილი ოპერაციების პაკეტი გაეშვება მხოლოდ ერთხელ, მიუხედავად ცვლადის ზომისა. ცვლადს მნიშვნელობა რომ შევუცვალოთ, ოპერაციების რაოდენობა არ შეიცვლება

const jami = 0;
const m = 500;
for( let m= 0; m<= 500; m++) {sum+=m}
// ამის კომპლექსურობა არის O(3*m+2) ამის ზუსტი ჩანაწერი არის O(m)
// ეს ნიშნავს, რომ ოპერაციების რაოდენობა გაიზრდება m ის ზომის ზრდასთან ერთად

const testResults = [22, 44, 55, 66, 66, 88, 99];

for (let i = 0; i < testResults.length; i++) {
  for (let j = i + 1; j < testResults.length; j++) {
    if (testResults[i] == testResults[j]) {
      console.log(`ვიპოვნე დუბლრებული ${testResults[i]}`);
    }
  }
}

// ამ შემთხვევაში n არის ერეის მონაცემების რაოდენობა. რომელიც იზრდება თავისთავჯერ. ანუ n2 ჯერ
// პირველი ლუპი რომ შესრულდება შესრულდება 10 ოპერაცია და პარალელურად 9 ოპერაცია. მეორე იტერაციაზეც ეგრე სანამ 10 მდე არ ავა. ანუ დაახლოებით 10*10 ოპერაცია სრულდება
//ამ კოდის კომპლექსურობა არის O(n2)
// Number, boolean, null, undefined აქვს O(1) კომპლექსურობა
// string, array ს აქვთ O(n) კომპლექსურობა


